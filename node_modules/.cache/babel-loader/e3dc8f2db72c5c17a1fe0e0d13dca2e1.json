{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport { tf } from 'tfjs-tiny-yolov2';\nimport { extractFaces, extractFaceTensors } from '../dom';\nimport { extendWithFaceExpressions } from '../factories/WithFaceExpressions';\nimport { ComposableTask } from './ComposableTask';\nimport { DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask } from './DetectFaceLandmarksTasks';\nimport { nets } from './nets';\n\nvar PredictFaceExpressionsTaskBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PredictFaceExpressionsTaskBase, _super);\n\n  function PredictFaceExpressionsTaskBase(parentTask, input) {\n    var _this = _super.call(this) || this;\n\n    _this.parentTask = parentTask;\n    _this.input = input;\n    return _this;\n  }\n\n  return PredictFaceExpressionsTaskBase;\n}(ComposableTask);\n\nexport { PredictFaceExpressionsTaskBase };\n\nvar PredictAllFaceExpressionsTask =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PredictAllFaceExpressionsTask, _super);\n\n  function PredictAllFaceExpressionsTask() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PredictAllFaceExpressionsTask.prototype.run = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var parentResults, detections, faces, _a, faceExpressionsByFace;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.parentTask];\n\n          case 1:\n            parentResults = _b.sent();\n            detections = parentResults.map(function (parentResult) {\n              return parentResult.detection;\n            });\n            if (!(this.input instanceof tf.Tensor)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , extractFaceTensors(this.input, detections)];\n\n          case 2:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , extractFaces(this.input, detections)];\n\n          case 4:\n            _a = _b.sent();\n            _b.label = 5;\n\n          case 5:\n            faces = _a;\n            return [4\n            /*yield*/\n            , Promise.all(faces.map(function (face) {\n              return nets.faceExpressionNet.predictExpressions(face);\n            }))];\n\n          case 6:\n            faceExpressionsByFace = _b.sent();\n            faces.forEach(function (f) {\n              return f instanceof tf.Tensor && f.dispose();\n            });\n            return [2\n            /*return*/\n            , parentResults.map(function (parentResult, i) {\n              return extendWithFaceExpressions(parentResult, faceExpressionsByFace[i]);\n            })];\n        }\n      });\n    });\n  };\n\n  PredictAllFaceExpressionsTask.prototype.withFaceLandmarks = function () {\n    return new DetectAllFaceLandmarksTask(this, this.input, false);\n  };\n\n  return PredictAllFaceExpressionsTask;\n}(PredictFaceExpressionsTaskBase);\n\nexport { PredictAllFaceExpressionsTask };\n\nvar PredictSingleFaceExpressionTask =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(PredictSingleFaceExpressionTask, _super);\n\n  function PredictSingleFaceExpressionTask() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  PredictSingleFaceExpressionTask.prototype.run = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var parentResult, detection, faces, _a, faceExpressions;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.parentTask];\n\n          case 1:\n            parentResult = _b.sent();\n\n            if (!parentResult) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            detection = parentResult.detection;\n            if (!(this.input instanceof tf.Tensor)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , extractFaceTensors(this.input, [detection])];\n\n          case 2:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , extractFaces(this.input, [detection])];\n\n          case 4:\n            _a = _b.sent();\n            _b.label = 5;\n\n          case 5:\n            faces = _a;\n            return [4\n            /*yield*/\n            , nets.faceExpressionNet.predictExpressions(faces[0])];\n\n          case 6:\n            faceExpressions = _b.sent();\n            faces.forEach(function (f) {\n              return f instanceof tf.Tensor && f.dispose();\n            });\n            return [2\n            /*return*/\n            , extendWithFaceExpressions(parentResult, faceExpressions)];\n        }\n      });\n    });\n  };\n\n  PredictSingleFaceExpressionTask.prototype.withFaceLandmarks = function () {\n    return new DetectSingleFaceLandmarksTask(this, this.input, false);\n  };\n\n  return PredictSingleFaceExpressionTask;\n}(PredictFaceExpressionsTaskBase);\n\nexport { PredictSingleFaceExpressionTask };","map":{"version":3,"sources":["../../../src/globalApi/PredictFaceExpressionsTask.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\r\nimport { tf } from 'tfjs-tiny-yolov2';\r\nimport { extractFaces, extractFaceTensors } from '../dom';\r\nimport { extendWithFaceExpressions } from '../factories/WithFaceExpressions';\r\nimport { ComposableTask } from './ComposableTask';\r\nimport { DetectAllFaceLandmarksTask, DetectSingleFaceLandmarksTask } from './DetectFaceLandmarksTasks';\r\nimport { nets } from './nets';\r\nvar PredictFaceExpressionsTaskBase = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PredictFaceExpressionsTaskBase, _super);\r\n    function PredictFaceExpressionsTaskBase(parentTask, input) {\r\n        var _this = _super.call(this) || this;\r\n        _this.parentTask = parentTask;\r\n        _this.input = input;\r\n        return _this;\r\n    }\r\n    return PredictFaceExpressionsTaskBase;\r\n}(ComposableTask));\r\nexport { PredictFaceExpressionsTaskBase };\r\nvar PredictAllFaceExpressionsTask = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PredictAllFaceExpressionsTask, _super);\r\n    function PredictAllFaceExpressionsTask() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    PredictAllFaceExpressionsTask.prototype.run = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var parentResults, detections, faces, _a, faceExpressionsByFace;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, this.parentTask];\r\n                    case 1:\r\n                        parentResults = _b.sent();\r\n                        detections = parentResults.map(function (parentResult) { return parentResult.detection; });\r\n                        if (!(this.input instanceof tf.Tensor)) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, extractFaceTensors(this.input, detections)];\r\n                    case 2:\r\n                        _a = _b.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 3: return [4 /*yield*/, extractFaces(this.input, detections)];\r\n                    case 4:\r\n                        _a = _b.sent();\r\n                        _b.label = 5;\r\n                    case 5:\r\n                        faces = _a;\r\n                        return [4 /*yield*/, Promise.all(faces.map(function (face) { return nets.faceExpressionNet.predictExpressions(face); }))];\r\n                    case 6:\r\n                        faceExpressionsByFace = _b.sent();\r\n                        faces.forEach(function (f) { return f instanceof tf.Tensor && f.dispose(); });\r\n                        return [2 /*return*/, parentResults.map(function (parentResult, i) { return extendWithFaceExpressions(parentResult, faceExpressionsByFace[i]); })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    PredictAllFaceExpressionsTask.prototype.withFaceLandmarks = function () {\r\n        return new DetectAllFaceLandmarksTask(this, this.input, false);\r\n    };\r\n    return PredictAllFaceExpressionsTask;\r\n}(PredictFaceExpressionsTaskBase));\r\nexport { PredictAllFaceExpressionsTask };\r\nvar PredictSingleFaceExpressionTask = /** @class */ (function (_super) {\r\n    tslib_1.__extends(PredictSingleFaceExpressionTask, _super);\r\n    function PredictSingleFaceExpressionTask() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    PredictSingleFaceExpressionTask.prototype.run = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var parentResult, detection, faces, _a, faceExpressions;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, this.parentTask];\r\n                    case 1:\r\n                        parentResult = _b.sent();\r\n                        if (!parentResult) {\r\n                            return [2 /*return*/];\r\n                        }\r\n                        detection = parentResult.detection;\r\n                        if (!(this.input instanceof tf.Tensor)) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, extractFaceTensors(this.input, [detection])];\r\n                    case 2:\r\n                        _a = _b.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 3: return [4 /*yield*/, extractFaces(this.input, [detection])];\r\n                    case 4:\r\n                        _a = _b.sent();\r\n                        _b.label = 5;\r\n                    case 5:\r\n                        faces = _a;\r\n                        return [4 /*yield*/, nets.faceExpressionNet.predictExpressions(faces[0])];\r\n                    case 6:\r\n                        faceExpressions = _b.sent();\r\n                        faces.forEach(function (f) { return f instanceof tf.Tensor && f.dispose(); });\r\n                        return [2 /*return*/, extendWithFaceExpressions(parentResult, faceExpressions)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    PredictSingleFaceExpressionTask.prototype.withFaceLandmarks = function () {\r\n        return new DetectSingleFaceLandmarksTask(this, this.input, false);\r\n    };\r\n    return PredictSingleFaceExpressionTask;\r\n}(PredictFaceExpressionsTaskBase));\r\nexport { PredictSingleFaceExpressionTask };\r\n//# sourceMappingURL=PredictFaceExpressionsTask.js.map"]},"metadata":{},"sourceType":"module"}