{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { computeReshapedDimensions, getMediaDimensions, imageToSquare, Rect, toNetInput } from 'tfjs-image-recognition-base';\nimport { validateTrainConfig } from './config';\nimport { getDefaultBackwardOptions } from './getDefaultBackwardOptions';\nimport { TinyYolov2 } from './TinyYolov2';\nimport { TinyYolov2LossFunction } from './TinyYolov2LossFunction';\n\nvar TinyYolov2Trainable =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(TinyYolov2Trainable, _super);\n\n  function TinyYolov2Trainable(trainableConfig, optimizer) {\n    var _this = _super.call(this, trainableConfig) || this;\n\n    _this._trainableConfig = validateTrainConfig(trainableConfig);\n    _this._optimizer = optimizer;\n    return _this;\n  }\n\n  Object.defineProperty(TinyYolov2Trainable.prototype, \"trainableConfig\", {\n    get: function get() {\n      return this._trainableConfig;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2Trainable.prototype, \"optimizer\", {\n    get: function get() {\n      return this._optimizer;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TinyYolov2Trainable.prototype.backward = function (img, groundTruth, inputSize, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      var _a, minBoxSize, reportLosses, reshapedImgDims, filteredGroundTruthBoxes, netInput, loss;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = getDefaultBackwardOptions(options), minBoxSize = _a.minBoxSize, reportLosses = _a.reportLosses;\n            reshapedImgDims = computeReshapedDimensions(getMediaDimensions(img), inputSize);\n            filteredGroundTruthBoxes = this.filterGroundTruthBoxes(groundTruth, reshapedImgDims, minBoxSize);\n\n            if (!filteredGroundTruthBoxes.length) {\n              return [2\n              /*return*/\n              , null];\n            }\n\n            return [4\n            /*yield*/\n            , toNetInput(imageToSquare(img, inputSize))];\n\n          case 1:\n            netInput = _b.sent();\n            loss = this.optimizer.minimize(function () {\n              var _a = _this.computeLoss(_this.forwardInput(netInput, inputSize), filteredGroundTruthBoxes, reshapedImgDims),\n                  noObjectLoss = _a.noObjectLoss,\n                  objectLoss = _a.objectLoss,\n                  coordLoss = _a.coordLoss,\n                  classLoss = _a.classLoss,\n                  totalLoss = _a.totalLoss;\n\n              if (reportLosses) {\n                var losses = {\n                  totalLoss: totalLoss.dataSync()[0],\n                  noObjectLoss: noObjectLoss.dataSync()[0],\n                  objectLoss: objectLoss.dataSync()[0],\n                  coordLoss: coordLoss.dataSync()[0],\n                  classLoss: classLoss.dataSync()[0]\n                };\n                var report = {\n                  losses: losses,\n                  numBoxes: filteredGroundTruthBoxes.length,\n                  inputSize: inputSize\n                };\n                reportLosses(report);\n              }\n\n              return totalLoss;\n            }, true);\n            return [2\n            /*return*/\n            , loss];\n        }\n      });\n    });\n  };\n\n  TinyYolov2Trainable.prototype.computeLoss = function (outputTensor, groundTruth, reshapedImgDims) {\n    var config = validateTrainConfig(this.config);\n    var inputSize = Math.max(reshapedImgDims.width, reshapedImgDims.height);\n\n    if (!inputSize) {\n      throw new Error(\"computeLoss - invalid inputSize: \" + inputSize);\n    }\n\n    var predictedBoxes = this.extractBoxes(outputTensor, reshapedImgDims);\n    return tf.tidy(function () {\n      var lossFunction = new TinyYolov2LossFunction(outputTensor, groundTruth, predictedBoxes, reshapedImgDims, config);\n      return lossFunction.computeLoss();\n    });\n  };\n\n  TinyYolov2Trainable.prototype.filterGroundTruthBoxes = function (groundTruth, imgDims, minBoxSize) {\n    var imgHeight = imgDims.height,\n        imgWidth = imgDims.width;\n    return groundTruth.filter(function (_a) {\n      var x = _a.x,\n          y = _a.y,\n          width = _a.width,\n          height = _a.height;\n      var box = new Rect(x, y, width, height).rescale({\n        height: imgHeight,\n        width: imgWidth\n      });\n      var isTooTiny = box.width < minBoxSize || box.height < minBoxSize;\n      return !isTooTiny;\n    });\n  };\n\n  TinyYolov2Trainable.prototype.load = function (weightsOrUrl) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , _super.prototype.load.call(this, weightsOrUrl)];\n\n          case 1:\n            _a.sent();\n\n            this.variable();\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  return TinyYolov2Trainable;\n}(TinyYolov2);\n\nexport { TinyYolov2Trainable };","map":{"version":3,"sources":["../../../src/tinyYolov2/TinyYolov2Trainable.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { computeReshapedDimensions, getMediaDimensions, imageToSquare, Rect, toNetInput, } from 'tfjs-image-recognition-base';\r\nimport { validateTrainConfig } from './config';\r\nimport { getDefaultBackwardOptions } from './getDefaultBackwardOptions';\r\nimport { TinyYolov2 } from './TinyYolov2';\r\nimport { TinyYolov2LossFunction } from './TinyYolov2LossFunction';\r\nvar TinyYolov2Trainable = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TinyYolov2Trainable, _super);\r\n    function TinyYolov2Trainable(trainableConfig, optimizer) {\r\n        var _this = _super.call(this, trainableConfig) || this;\r\n        _this._trainableConfig = validateTrainConfig(trainableConfig);\r\n        _this._optimizer = optimizer;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(TinyYolov2Trainable.prototype, \"trainableConfig\", {\r\n        get: function () {\r\n            return this._trainableConfig;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TinyYolov2Trainable.prototype, \"optimizer\", {\r\n        get: function () {\r\n            return this._optimizer;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    TinyYolov2Trainable.prototype.backward = function (img, groundTruth, inputSize, options) {\r\n        if (options === void 0) { options = {}; }\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            var _a, minBoxSize, reportLosses, reshapedImgDims, filteredGroundTruthBoxes, netInput, loss;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = getDefaultBackwardOptions(options), minBoxSize = _a.minBoxSize, reportLosses = _a.reportLosses;\r\n                        reshapedImgDims = computeReshapedDimensions(getMediaDimensions(img), inputSize);\r\n                        filteredGroundTruthBoxes = this.filterGroundTruthBoxes(groundTruth, reshapedImgDims, minBoxSize);\r\n                        if (!filteredGroundTruthBoxes.length) {\r\n                            return [2 /*return*/, null];\r\n                        }\r\n                        return [4 /*yield*/, toNetInput(imageToSquare(img, inputSize))];\r\n                    case 1:\r\n                        netInput = _b.sent();\r\n                        loss = this.optimizer.minimize(function () {\r\n                            var _a = _this.computeLoss(_this.forwardInput(netInput, inputSize), filteredGroundTruthBoxes, reshapedImgDims), noObjectLoss = _a.noObjectLoss, objectLoss = _a.objectLoss, coordLoss = _a.coordLoss, classLoss = _a.classLoss, totalLoss = _a.totalLoss;\r\n                            if (reportLosses) {\r\n                                var losses = {\r\n                                    totalLoss: totalLoss.dataSync()[0],\r\n                                    noObjectLoss: noObjectLoss.dataSync()[0],\r\n                                    objectLoss: objectLoss.dataSync()[0],\r\n                                    coordLoss: coordLoss.dataSync()[0],\r\n                                    classLoss: classLoss.dataSync()[0]\r\n                                };\r\n                                var report = {\r\n                                    losses: losses,\r\n                                    numBoxes: filteredGroundTruthBoxes.length,\r\n                                    inputSize: inputSize\r\n                                };\r\n                                reportLosses(report);\r\n                            }\r\n                            return totalLoss;\r\n                        }, true);\r\n                        return [2 /*return*/, loss];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TinyYolov2Trainable.prototype.computeLoss = function (outputTensor, groundTruth, reshapedImgDims) {\r\n        var config = validateTrainConfig(this.config);\r\n        var inputSize = Math.max(reshapedImgDims.width, reshapedImgDims.height);\r\n        if (!inputSize) {\r\n            throw new Error(\"computeLoss - invalid inputSize: \" + inputSize);\r\n        }\r\n        var predictedBoxes = this.extractBoxes(outputTensor, reshapedImgDims);\r\n        return tf.tidy(function () {\r\n            var lossFunction = new TinyYolov2LossFunction(outputTensor, groundTruth, predictedBoxes, reshapedImgDims, config);\r\n            return lossFunction.computeLoss();\r\n        });\r\n    };\r\n    TinyYolov2Trainable.prototype.filterGroundTruthBoxes = function (groundTruth, imgDims, minBoxSize) {\r\n        var imgHeight = imgDims.height, imgWidth = imgDims.width;\r\n        return groundTruth.filter(function (_a) {\r\n            var x = _a.x, y = _a.y, width = _a.width, height = _a.height;\r\n            var box = (new Rect(x, y, width, height))\r\n                .rescale({ height: imgHeight, width: imgWidth });\r\n            var isTooTiny = box.width < minBoxSize || box.height < minBoxSize;\r\n            return !isTooTiny;\r\n        });\r\n    };\r\n    TinyYolov2Trainable.prototype.load = function (weightsOrUrl) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, _super.prototype.load.call(this, weightsOrUrl)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        this.variable();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return TinyYolov2Trainable;\r\n}(TinyYolov2));\r\nexport { TinyYolov2Trainable };\r\n//# sourceMappingURL=TinyYolov2Trainable.js.map"]},"metadata":{},"sourceType":"module"}