{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { BoundingBox, NeuralNetwork, nonMaxSuppression, normalize, ObjectDetection, sigmoid, toNetInput } from 'tfjs-image-recognition-base';\nimport { convLayer } from '../common';\nimport { validateConfig } from './config';\nimport { DEFAULT_FILTER_SIZES } from './const';\nimport { convWithBatchNorm } from './convWithBatchNorm';\nimport { depthwiseSeparableConv } from './depthwiseSeparableConv';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { leaky } from './leaky';\nimport { TinyYolov2Options } from './TinyYolov2Options';\n\nvar TinyYolov2 =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(TinyYolov2, _super);\n\n  function TinyYolov2(config) {\n    var _this = _super.call(this, 'TinyYolov2') || this;\n\n    validateConfig(config);\n    _this._config = config;\n    return _this;\n  }\n\n  Object.defineProperty(TinyYolov2.prototype, \"config\", {\n    get: function get() {\n      return this._config;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2.prototype, \"withClassScores\", {\n    get: function get() {\n      return this.config.withClassScores || this.config.classes.length > 1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2.prototype, \"boxEncodingSize\", {\n    get: function get() {\n      return 5 + (this.withClassScores ? this.config.classes.length : 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  TinyYolov2.prototype.runTinyYolov2 = function (x, params) {\n    var out = convWithBatchNorm(x, params.conv0);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv1);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv2);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv3);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv4);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv5);\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\n    out = convWithBatchNorm(out, params.conv6);\n    out = convWithBatchNorm(out, params.conv7);\n    return convLayer(out, params.conv8, 'valid', false);\n  };\n\n  TinyYolov2.prototype.runMobilenet = function (x, params) {\n    var out = this.config.isFirstLayerConv2d ? leaky(convLayer(x, params.conv0, 'valid', false)) : depthwiseSeparableConv(x, params.conv0);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv1);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv2);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv3);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv4);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv5);\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\n    out = params.conv6 ? depthwiseSeparableConv(out, params.conv6) : out;\n    out = params.conv7 ? depthwiseSeparableConv(out, params.conv7) : out;\n    return convLayer(out, params.conv8, 'valid', false);\n  };\n\n  TinyYolov2.prototype.forwardInput = function (input, inputSize) {\n    var _this = this;\n\n    var params = this.params;\n\n    if (!params) {\n      throw new Error('TinyYolov2 - load model before inference');\n    }\n\n    return tf.tidy(function () {\n      var batchTensor = input.toBatchTensor(inputSize, false).toFloat();\n      batchTensor = _this.config.meanRgb ? normalize(batchTensor, _this.config.meanRgb) : batchTensor;\n      batchTensor = batchTensor.div(tf.scalar(256));\n      return _this.config.withSeparableConvs ? _this.runMobilenet(batchTensor, params) : _this.runTinyYolov2(batchTensor, params);\n    });\n  };\n\n  TinyYolov2.prototype.forward = function (input, inputSize) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            return [4\n            /*yield*/\n            , _a.apply(this, [_b.sent(), inputSize])];\n\n          case 2:\n            return [2\n            /*return*/\n            , _b.sent()];\n        }\n      });\n    });\n  };\n\n  TinyYolov2.prototype.detect = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      var _a, inputSize, scoreThreshold, netInput, out, out0, inputDimensions, results, boxes, scores, classScores, classNames, indices, detections;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = new TinyYolov2Options(forwardParams), inputSize = _a.inputSize, scoreThreshold = _a.scoreThreshold;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            netInput = _b.sent();\n            return [4\n            /*yield*/\n            , this.forwardInput(netInput, inputSize)];\n\n          case 2:\n            out = _b.sent();\n            out0 = tf.tidy(function () {\n              return tf.unstack(out)[0].expandDims();\n            });\n            inputDimensions = {\n              width: netInput.getInputWidth(0),\n              height: netInput.getInputHeight(0)\n            };\n            results = this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold);\n            out.dispose();\n            out0.dispose();\n            boxes = results.map(function (res) {\n              return res.box;\n            });\n            scores = results.map(function (res) {\n              return res.score;\n            });\n            classScores = results.map(function (res) {\n              return res.classScore;\n            });\n            classNames = results.map(function (res) {\n              return _this.config.classes[res.label];\n            });\n            indices = nonMaxSuppression(boxes.map(function (box) {\n              return box.rescale(inputSize);\n            }), scores, this.config.iouThreshold, true);\n            detections = indices.map(function (idx) {\n              return new ObjectDetection(scores[idx], classScores[idx], classNames[idx], boxes[idx], inputDimensions);\n            });\n            return [2\n            /*return*/\n            , detections];\n        }\n      });\n    });\n  };\n\n  TinyYolov2.prototype.getDefaultModelName = function () {\n    return '';\n  };\n\n  TinyYolov2.prototype.extractParamsFromWeigthMap = function (weightMap) {\n    return extractParamsFromWeigthMap(weightMap, this.config);\n  };\n\n  TinyYolov2.prototype.extractParams = function (weights) {\n    var filterSizes = this.config.filterSizes || DEFAULT_FILTER_SIZES;\n    var numFilters = filterSizes ? filterSizes.length : undefined;\n\n    if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {\n      throw new Error(\"TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found \" + numFilters + \" filterSizes in config\");\n    }\n\n    return extractParams(weights, this.config, this.boxEncodingSize, filterSizes);\n  };\n\n  TinyYolov2.prototype.extractBoxes = function (outputTensor, inputBlobDimensions, scoreThreshold) {\n    var _this = this;\n\n    var width = inputBlobDimensions.width,\n        height = inputBlobDimensions.height;\n    var inputSize = Math.max(width, height);\n    var correctionFactorX = inputSize / width;\n    var correctionFactorY = inputSize / height;\n    var numCells = outputTensor.shape[1];\n    var numBoxes = this.config.anchors.length;\n\n    var _a = tf.tidy(function () {\n      var reshaped = outputTensor.reshape([numCells, numCells, numBoxes, _this.boxEncodingSize]);\n      var boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);\n      var scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);\n      var classScores = _this.withClassScores ? tf.softmax(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, _this.config.classes.length]), 3) : tf.scalar(0);\n      return [boxes, scores, classScores];\n    }),\n        boxesTensor = _a[0],\n        scoresTensor = _a[1],\n        classScoresTensor = _a[2];\n\n    var results = [];\n\n    for (var row = 0; row < numCells; row++) {\n      for (var col = 0; col < numCells; col++) {\n        for (var anchor = 0; anchor < numBoxes; anchor++) {\n          var score = sigmoid(scoresTensor.get(row, col, anchor, 0));\n\n          if (!scoreThreshold || score > scoreThreshold) {\n            var ctX = (col + sigmoid(boxesTensor.get(row, col, anchor, 0))) / numCells * correctionFactorX;\n            var ctY = (row + sigmoid(boxesTensor.get(row, col, anchor, 1))) / numCells * correctionFactorY;\n            var width_1 = Math.exp(boxesTensor.get(row, col, anchor, 2)) * this.config.anchors[anchor].x / numCells * correctionFactorX;\n            var height_1 = Math.exp(boxesTensor.get(row, col, anchor, 3)) * this.config.anchors[anchor].y / numCells * correctionFactorY;\n            var x = ctX - width_1 / 2;\n            var y = ctY - height_1 / 2;\n            var pos = {\n              row: row,\n              col: col,\n              anchor: anchor\n            };\n\n            var _b = this.withClassScores ? this.extractPredictedClass(classScoresTensor, pos) : {\n              classScore: 1,\n              label: 0\n            },\n                classScore = _b.classScore,\n                label = _b.label;\n\n            results.push(tslib_1.__assign({\n              box: new BoundingBox(x, y, x + width_1, y + height_1),\n              score: score,\n              classScore: score * classScore,\n              label: label\n            }, pos));\n          }\n        }\n      }\n    }\n\n    boxesTensor.dispose();\n    scoresTensor.dispose();\n    classScoresTensor.dispose();\n    return results;\n  };\n\n  TinyYolov2.prototype.extractPredictedClass = function (classesTensor, pos) {\n    var row = pos.row,\n        col = pos.col,\n        anchor = pos.anchor;\n    return Array(this.config.classes.length).fill(0).map(function (_, i) {\n      return classesTensor.get(row, col, anchor, i);\n    }).map(function (classScore, label) {\n      return {\n        classScore: classScore,\n        label: label\n      };\n    }).reduce(function (max, curr) {\n      return max.classScore > curr.classScore ? max : curr;\n    });\n  };\n\n  return TinyYolov2;\n}(NeuralNetwork);\n\nexport { TinyYolov2 };","map":{"version":3,"sources":["../../../src/tinyYolov2/TinyYolov2.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { BoundingBox, NeuralNetwork, nonMaxSuppression, normalize, ObjectDetection, sigmoid, toNetInput, } from 'tfjs-image-recognition-base';\r\nimport { convLayer } from '../common';\r\nimport { validateConfig } from './config';\r\nimport { DEFAULT_FILTER_SIZES } from './const';\r\nimport { convWithBatchNorm } from './convWithBatchNorm';\r\nimport { depthwiseSeparableConv } from './depthwiseSeparableConv';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\r\nimport { leaky } from './leaky';\r\nimport { TinyYolov2Options } from './TinyYolov2Options';\r\nvar TinyYolov2 = /** @class */ (function (_super) {\r\n    tslib_1.__extends(TinyYolov2, _super);\r\n    function TinyYolov2(config) {\r\n        var _this = _super.call(this, 'TinyYolov2') || this;\r\n        validateConfig(config);\r\n        _this._config = config;\r\n        return _this;\r\n    }\r\n    Object.defineProperty(TinyYolov2.prototype, \"config\", {\r\n        get: function () {\r\n            return this._config;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TinyYolov2.prototype, \"withClassScores\", {\r\n        get: function () {\r\n            return this.config.withClassScores || this.config.classes.length > 1;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(TinyYolov2.prototype, \"boxEncodingSize\", {\r\n        get: function () {\r\n            return 5 + (this.withClassScores ? this.config.classes.length : 0);\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    TinyYolov2.prototype.runTinyYolov2 = function (x, params) {\r\n        var out = convWithBatchNorm(x, params.conv0);\r\n        out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n        out = convWithBatchNorm(out, params.conv1);\r\n        out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n        out = convWithBatchNorm(out, params.conv2);\r\n        out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n        out = convWithBatchNorm(out, params.conv3);\r\n        out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n        out = convWithBatchNorm(out, params.conv4);\r\n        out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n        out = convWithBatchNorm(out, params.conv5);\r\n        out = tf.maxPool(out, [2, 2], [1, 1], 'same');\r\n        out = convWithBatchNorm(out, params.conv6);\r\n        out = convWithBatchNorm(out, params.conv7);\r\n        return convLayer(out, params.conv8, 'valid', false);\r\n    };\r\n    TinyYolov2.prototype.runMobilenet = function (x, params) {\r\n        var out = this.config.isFirstLayerConv2d\r\n            ? leaky(convLayer(x, params.conv0, 'valid', false))\r\n            : depthwiseSeparableConv(x, params.conv0);\r\n        out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n        out = depthwiseSeparableConv(out, params.conv1);\r\n        out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n        out = depthwiseSeparableConv(out, params.conv2);\r\n        out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n        out = depthwiseSeparableConv(out, params.conv3);\r\n        out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n        out = depthwiseSeparableConv(out, params.conv4);\r\n        out = tf.maxPool(out, [2, 2], [2, 2], 'same');\r\n        out = depthwiseSeparableConv(out, params.conv5);\r\n        out = tf.maxPool(out, [2, 2], [1, 1], 'same');\r\n        out = params.conv6 ? depthwiseSeparableConv(out, params.conv6) : out;\r\n        out = params.conv7 ? depthwiseSeparableConv(out, params.conv7) : out;\r\n        return convLayer(out, params.conv8, 'valid', false);\r\n    };\r\n    TinyYolov2.prototype.forwardInput = function (input, inputSize) {\r\n        var _this = this;\r\n        var params = this.params;\r\n        if (!params) {\r\n            throw new Error('TinyYolov2 - load model before inference');\r\n        }\r\n        return tf.tidy(function () {\r\n            var batchTensor = input.toBatchTensor(inputSize, false).toFloat();\r\n            batchTensor = _this.config.meanRgb\r\n                ? normalize(batchTensor, _this.config.meanRgb)\r\n                : batchTensor;\r\n            batchTensor = batchTensor.div(tf.scalar(256));\r\n            return _this.config.withSeparableConvs\r\n                ? _this.runMobilenet(batchTensor, params)\r\n                : _this.runTinyYolov2(batchTensor, params);\r\n        });\r\n    };\r\n    TinyYolov2.prototype.forward = function (input, inputSize) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this.forwardInput;\r\n                        return [4 /*yield*/, toNetInput(input)];\r\n                    case 1: return [4 /*yield*/, _a.apply(this, [_b.sent(), inputSize])];\r\n                    case 2: return [2 /*return*/, _b.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TinyYolov2.prototype.detect = function (input, forwardParams) {\r\n        if (forwardParams === void 0) { forwardParams = {}; }\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            var _a, inputSize, scoreThreshold, netInput, out, out0, inputDimensions, results, boxes, scores, classScores, classNames, indices, detections;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = new TinyYolov2Options(forwardParams), inputSize = _a.inputSize, scoreThreshold = _a.scoreThreshold;\r\n                        return [4 /*yield*/, toNetInput(input)];\r\n                    case 1:\r\n                        netInput = _b.sent();\r\n                        return [4 /*yield*/, this.forwardInput(netInput, inputSize)];\r\n                    case 2:\r\n                        out = _b.sent();\r\n                        out0 = tf.tidy(function () { return tf.unstack(out)[0].expandDims(); });\r\n                        inputDimensions = {\r\n                            width: netInput.getInputWidth(0),\r\n                            height: netInput.getInputHeight(0)\r\n                        };\r\n                        results = this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold);\r\n                        out.dispose();\r\n                        out0.dispose();\r\n                        boxes = results.map(function (res) { return res.box; });\r\n                        scores = results.map(function (res) { return res.score; });\r\n                        classScores = results.map(function (res) { return res.classScore; });\r\n                        classNames = results.map(function (res) { return _this.config.classes[res.label]; });\r\n                        indices = nonMaxSuppression(boxes.map(function (box) { return box.rescale(inputSize); }), scores, this.config.iouThreshold, true);\r\n                        detections = indices.map(function (idx) {\r\n                            return new ObjectDetection(scores[idx], classScores[idx], classNames[idx], boxes[idx], inputDimensions);\r\n                        });\r\n                        return [2 /*return*/, detections];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    TinyYolov2.prototype.getDefaultModelName = function () {\r\n        return '';\r\n    };\r\n    TinyYolov2.prototype.extractParamsFromWeigthMap = function (weightMap) {\r\n        return extractParamsFromWeigthMap(weightMap, this.config);\r\n    };\r\n    TinyYolov2.prototype.extractParams = function (weights) {\r\n        var filterSizes = this.config.filterSizes || DEFAULT_FILTER_SIZES;\r\n        var numFilters = filterSizes ? filterSizes.length : undefined;\r\n        if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {\r\n            throw new Error(\"TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found \" + numFilters + \" filterSizes in config\");\r\n        }\r\n        return extractParams(weights, this.config, this.boxEncodingSize, filterSizes);\r\n    };\r\n    TinyYolov2.prototype.extractBoxes = function (outputTensor, inputBlobDimensions, scoreThreshold) {\r\n        var _this = this;\r\n        var width = inputBlobDimensions.width, height = inputBlobDimensions.height;\r\n        var inputSize = Math.max(width, height);\r\n        var correctionFactorX = inputSize / width;\r\n        var correctionFactorY = inputSize / height;\r\n        var numCells = outputTensor.shape[1];\r\n        var numBoxes = this.config.anchors.length;\r\n        var _a = tf.tidy(function () {\r\n            var reshaped = outputTensor.reshape([numCells, numCells, numBoxes, _this.boxEncodingSize]);\r\n            var boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);\r\n            var scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);\r\n            var classScores = _this.withClassScores\r\n                ? tf.softmax(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, _this.config.classes.length]), 3)\r\n                : tf.scalar(0);\r\n            return [boxes, scores, classScores];\r\n        }), boxesTensor = _a[0], scoresTensor = _a[1], classScoresTensor = _a[2];\r\n        var results = [];\r\n        for (var row = 0; row < numCells; row++) {\r\n            for (var col = 0; col < numCells; col++) {\r\n                for (var anchor = 0; anchor < numBoxes; anchor++) {\r\n                    var score = sigmoid(scoresTensor.get(row, col, anchor, 0));\r\n                    if (!scoreThreshold || score > scoreThreshold) {\r\n                        var ctX = ((col + sigmoid(boxesTensor.get(row, col, anchor, 0))) / numCells) * correctionFactorX;\r\n                        var ctY = ((row + sigmoid(boxesTensor.get(row, col, anchor, 1))) / numCells) * correctionFactorY;\r\n                        var width_1 = ((Math.exp(boxesTensor.get(row, col, anchor, 2)) * this.config.anchors[anchor].x) / numCells) * correctionFactorX;\r\n                        var height_1 = ((Math.exp(boxesTensor.get(row, col, anchor, 3)) * this.config.anchors[anchor].y) / numCells) * correctionFactorY;\r\n                        var x = (ctX - (width_1 / 2));\r\n                        var y = (ctY - (height_1 / 2));\r\n                        var pos = { row: row, col: col, anchor: anchor };\r\n                        var _b = this.withClassScores\r\n                            ? this.extractPredictedClass(classScoresTensor, pos)\r\n                            : { classScore: 1, label: 0 }, classScore = _b.classScore, label = _b.label;\r\n                        results.push(tslib_1.__assign({ box: new BoundingBox(x, y, x + width_1, y + height_1), score: score, classScore: score * classScore, label: label }, pos));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        boxesTensor.dispose();\r\n        scoresTensor.dispose();\r\n        classScoresTensor.dispose();\r\n        return results;\r\n    };\r\n    TinyYolov2.prototype.extractPredictedClass = function (classesTensor, pos) {\r\n        var row = pos.row, col = pos.col, anchor = pos.anchor;\r\n        return Array(this.config.classes.length).fill(0)\r\n            .map(function (_, i) { return classesTensor.get(row, col, anchor, i); })\r\n            .map(function (classScore, label) { return ({\r\n            classScore: classScore,\r\n            label: label\r\n        }); })\r\n            .reduce(function (max, curr) { return max.classScore > curr.classScore ? max : curr; });\r\n    };\r\n    return TinyYolov2;\r\n}(NeuralNetwork));\r\nexport { TinyYolov2 };\r\n//# sourceMappingURL=TinyYolov2.js.map"]},"metadata":{},"sourceType":"module"}