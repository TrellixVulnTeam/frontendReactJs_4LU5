{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { toNetInput } from 'tfjs-image-recognition-base';\nimport { FaceFeatureExtractor } from '../faceFeatureExtractor/FaceFeatureExtractor';\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\nimport { faceExpressionLabels } from './types';\n\nvar FaceExpressionNet =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(FaceExpressionNet, _super);\n\n  function FaceExpressionNet(faceFeatureExtractor) {\n    if (faceFeatureExtractor === void 0) {\n      faceFeatureExtractor = new FaceFeatureExtractor();\n    }\n\n    return _super.call(this, 'FaceExpressionNet', faceFeatureExtractor) || this;\n  }\n\n  FaceExpressionNet.getFaceExpressionLabel = function (faceExpression) {\n    var label = faceExpressionLabels[faceExpression];\n\n    if (typeof label !== 'number') {\n      throw new Error(\"getFaceExpressionLabel - no label for faceExpression: \" + faceExpression);\n    }\n\n    return label;\n  };\n\n  FaceExpressionNet.decodeProbabilites = function (probabilities) {\n    if (probabilities.length !== 7) {\n      throw new Error(\"decodeProbabilites - expected probabilities.length to be 7, have: \" + probabilities.length);\n    }\n\n    return Object.keys(faceExpressionLabels).map(function (expression) {\n      return {\n        expression: expression,\n        probability: probabilities[faceExpressionLabels[expression]]\n      };\n    });\n  };\n\n  FaceExpressionNet.prototype.forwardInput = function (input) {\n    var _this = this;\n\n    return tf.tidy(function () {\n      return tf.softmax(_this.runNet(input));\n    });\n  };\n\n  FaceExpressionNet.prototype.forward = function (input) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _a;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.apply(this, [_b.sent()])];\n        }\n      });\n    });\n  };\n\n  FaceExpressionNet.prototype.predictExpressions = function (input) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      var netInput, out, probabilitesByBatch, predictionsByBatch;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , toNetInput(input)];\n\n          case 1:\n            netInput = _a.sent();\n            return [4\n            /*yield*/\n            , this.forwardInput(netInput)];\n\n          case 2:\n            out = _a.sent();\n            return [4\n            /*yield*/\n            , Promise.all(tf.unstack(out).map(function (t) {\n              return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                var data;\n                return tslib_1.__generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , t.data()];\n\n                    case 1:\n                      data = _a.sent();\n                      t.dispose();\n                      return [2\n                      /*return*/\n                      , data];\n                  }\n                });\n              });\n            }))];\n\n          case 3:\n            probabilitesByBatch = _a.sent();\n            out.dispose();\n            predictionsByBatch = probabilitesByBatch.map(function (propablities) {\n              return FaceExpressionNet.decodeProbabilites(propablities);\n            });\n            return [2\n            /*return*/\n            , netInput.isBatchInput ? predictionsByBatch : predictionsByBatch[0]];\n        }\n      });\n    });\n  };\n\n  FaceExpressionNet.prototype.getDefaultModelName = function () {\n    return 'face_expression_model';\n  };\n\n  FaceExpressionNet.prototype.getClassifierChannelsIn = function () {\n    return 256;\n  };\n\n  FaceExpressionNet.prototype.getClassifierChannelsOut = function () {\n    return 7;\n  };\n\n  return FaceExpressionNet;\n}(FaceProcessor);\n\nexport { FaceExpressionNet };","map":{"version":3,"sources":["../../../src/faceExpressionNet/FaceExpressionNet.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { toNetInput } from 'tfjs-image-recognition-base';\r\nimport { FaceFeatureExtractor } from '../faceFeatureExtractor/FaceFeatureExtractor';\r\nimport { FaceProcessor } from '../faceProcessor/FaceProcessor';\r\nimport { faceExpressionLabels } from './types';\r\nvar FaceExpressionNet = /** @class */ (function (_super) {\r\n    tslib_1.__extends(FaceExpressionNet, _super);\r\n    function FaceExpressionNet(faceFeatureExtractor) {\r\n        if (faceFeatureExtractor === void 0) { faceFeatureExtractor = new FaceFeatureExtractor(); }\r\n        return _super.call(this, 'FaceExpressionNet', faceFeatureExtractor) || this;\r\n    }\r\n    FaceExpressionNet.getFaceExpressionLabel = function (faceExpression) {\r\n        var label = faceExpressionLabels[faceExpression];\r\n        if (typeof label !== 'number') {\r\n            throw new Error(\"getFaceExpressionLabel - no label for faceExpression: \" + faceExpression);\r\n        }\r\n        return label;\r\n    };\r\n    FaceExpressionNet.decodeProbabilites = function (probabilities) {\r\n        if (probabilities.length !== 7) {\r\n            throw new Error(\"decodeProbabilites - expected probabilities.length to be 7, have: \" + probabilities.length);\r\n        }\r\n        return Object.keys(faceExpressionLabels)\r\n            .map(function (expression) { return ({ expression: expression, probability: probabilities[faceExpressionLabels[expression]] }); });\r\n    };\r\n    FaceExpressionNet.prototype.forwardInput = function (input) {\r\n        var _this = this;\r\n        return tf.tidy(function () { return tf.softmax(_this.runNet(input)); });\r\n    };\r\n    FaceExpressionNet.prototype.forward = function (input) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this.forwardInput;\r\n                        return [4 /*yield*/, toNetInput(input)];\r\n                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FaceExpressionNet.prototype.predictExpressions = function (input) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            var netInput, out, probabilitesByBatch, predictionsByBatch;\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, toNetInput(input)];\r\n                    case 1:\r\n                        netInput = _a.sent();\r\n                        return [4 /*yield*/, this.forwardInput(netInput)];\r\n                    case 2:\r\n                        out = _a.sent();\r\n                        return [4 /*yield*/, Promise.all(tf.unstack(out).map(function (t) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\r\n                                var data;\r\n                                return tslib_1.__generator(this, function (_a) {\r\n                                    switch (_a.label) {\r\n                                        case 0: return [4 /*yield*/, t.data()];\r\n                                        case 1:\r\n                                            data = _a.sent();\r\n                                            t.dispose();\r\n                                            return [2 /*return*/, data];\r\n                                    }\r\n                                });\r\n                            }); }))];\r\n                    case 3:\r\n                        probabilitesByBatch = _a.sent();\r\n                        out.dispose();\r\n                        predictionsByBatch = probabilitesByBatch\r\n                            .map(function (propablities) { return FaceExpressionNet.decodeProbabilites(propablities); });\r\n                        return [2 /*return*/, netInput.isBatchInput\r\n                                ? predictionsByBatch\r\n                                : predictionsByBatch[0]];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    FaceExpressionNet.prototype.getDefaultModelName = function () {\r\n        return 'face_expression_model';\r\n    };\r\n    FaceExpressionNet.prototype.getClassifierChannelsIn = function () {\r\n        return 256;\r\n    };\r\n    FaceExpressionNet.prototype.getClassifierChannelsOut = function () {\r\n        return 7;\r\n    };\r\n    return FaceExpressionNet;\r\n}(FaceProcessor));\r\nexport { FaceExpressionNet };\r\n//# sourceMappingURL=FaceExpressionNet.js.map"]},"metadata":{},"sourceType":"module"}