{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { extractFaces, extractFaceTensors } from '../dom';\nimport { extendWithFaceDescriptor } from '../factories/WithFaceDescriptor';\nimport { ComposableTask } from './ComposableTask';\nimport { nets } from './nets';\n\nvar ComputeFaceDescriptorsTaskBase =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ComputeFaceDescriptorsTaskBase, _super);\n\n  function ComputeFaceDescriptorsTaskBase(parentTask, input) {\n    var _this = _super.call(this) || this;\n\n    _this.parentTask = parentTask;\n    _this.input = input;\n    return _this;\n  }\n\n  return ComputeFaceDescriptorsTaskBase;\n}(ComposableTask);\n\nexport { ComputeFaceDescriptorsTaskBase };\n\nvar ComputeAllFaceDescriptorsTask =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ComputeAllFaceDescriptorsTask, _super);\n\n  function ComputeAllFaceDescriptorsTask() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ComputeAllFaceDescriptorsTask.prototype.run = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      var parentResults, alignedRects, alignedFaces, _a, results;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.parentTask];\n\n          case 1:\n            parentResults = _b.sent();\n            alignedRects = parentResults.map(function (_a) {\n              var alignedRect = _a.alignedRect;\n              return alignedRect;\n            });\n            if (!(this.input instanceof tf.Tensor)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , extractFaceTensors(this.input, alignedRects)];\n\n          case 2:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , extractFaces(this.input, alignedRects)];\n\n          case 4:\n            _a = _b.sent();\n            _b.label = 5;\n\n          case 5:\n            alignedFaces = _a;\n            return [4\n            /*yield*/\n            , Promise.all(parentResults.map(function (parentResult, i) {\n              return tslib_1.__awaiter(_this, void 0, void 0, function () {\n                var descriptor;\n                return tslib_1.__generator(this, function (_a) {\n                  switch (_a.label) {\n                    case 0:\n                      return [4\n                      /*yield*/\n                      , nets.faceRecognitionNet.computeFaceDescriptor(alignedFaces[i])];\n\n                    case 1:\n                      descriptor = _a.sent();\n                      return [2\n                      /*return*/\n                      , extendWithFaceDescriptor(parentResult, descriptor)];\n                  }\n                });\n              });\n            }))];\n\n          case 6:\n            results = _b.sent();\n            alignedFaces.forEach(function (f) {\n              return f instanceof tf.Tensor && f.dispose();\n            });\n            return [2\n            /*return*/\n            , results];\n        }\n      });\n    });\n  };\n\n  return ComputeAllFaceDescriptorsTask;\n}(ComputeFaceDescriptorsTaskBase);\n\nexport { ComputeAllFaceDescriptorsTask };\n\nvar ComputeSingleFaceDescriptorTask =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(ComputeSingleFaceDescriptorTask, _super);\n\n  function ComputeSingleFaceDescriptorTask() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ComputeSingleFaceDescriptorTask.prototype.run = function () {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var parentResult, alignedRect, alignedFaces, _a, descriptor;\n\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.parentTask];\n\n          case 1:\n            parentResult = _b.sent();\n\n            if (!parentResult) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            alignedRect = parentResult.alignedRect;\n            if (!(this.input instanceof tf.Tensor)) return [3\n            /*break*/\n            , 3];\n            return [4\n            /*yield*/\n            , extractFaceTensors(this.input, [alignedRect])];\n\n          case 2:\n            _a = _b.sent();\n            return [3\n            /*break*/\n            , 5];\n\n          case 3:\n            return [4\n            /*yield*/\n            , extractFaces(this.input, [alignedRect])];\n\n          case 4:\n            _a = _b.sent();\n            _b.label = 5;\n\n          case 5:\n            alignedFaces = _a;\n            return [4\n            /*yield*/\n            , nets.faceRecognitionNet.computeFaceDescriptor(alignedFaces[0])];\n\n          case 6:\n            descriptor = _b.sent();\n            alignedFaces.forEach(function (f) {\n              return f instanceof tf.Tensor && f.dispose();\n            });\n            return [2\n            /*return*/\n            , extendWithFaceDescriptor(parentResult, descriptor)];\n        }\n      });\n    });\n  };\n\n  return ComputeSingleFaceDescriptorTask;\n}(ComputeFaceDescriptorsTaskBase);\n\nexport { ComputeSingleFaceDescriptorTask };","map":{"version":3,"sources":["../../../src/globalApi/ComputeFaceDescriptorsTasks.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as tslib_1 from \"tslib\";\r\nimport * as tf from '@tensorflow/tfjs-core';\r\nimport { extractFaces, extractFaceTensors } from '../dom';\r\nimport { extendWithFaceDescriptor } from '../factories/WithFaceDescriptor';\r\nimport { ComposableTask } from './ComposableTask';\r\nimport { nets } from './nets';\r\nvar ComputeFaceDescriptorsTaskBase = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ComputeFaceDescriptorsTaskBase, _super);\r\n    function ComputeFaceDescriptorsTaskBase(parentTask, input) {\r\n        var _this = _super.call(this) || this;\r\n        _this.parentTask = parentTask;\r\n        _this.input = input;\r\n        return _this;\r\n    }\r\n    return ComputeFaceDescriptorsTaskBase;\r\n}(ComposableTask));\r\nexport { ComputeFaceDescriptorsTaskBase };\r\nvar ComputeAllFaceDescriptorsTask = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ComputeAllFaceDescriptorsTask, _super);\r\n    function ComputeAllFaceDescriptorsTask() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ComputeAllFaceDescriptorsTask.prototype.run = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            var parentResults, alignedRects, alignedFaces, _a, results;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, this.parentTask];\r\n                    case 1:\r\n                        parentResults = _b.sent();\r\n                        alignedRects = parentResults.map(function (_a) {\r\n                            var alignedRect = _a.alignedRect;\r\n                            return alignedRect;\r\n                        });\r\n                        if (!(this.input instanceof tf.Tensor)) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, extractFaceTensors(this.input, alignedRects)];\r\n                    case 2:\r\n                        _a = _b.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 3: return [4 /*yield*/, extractFaces(this.input, alignedRects)];\r\n                    case 4:\r\n                        _a = _b.sent();\r\n                        _b.label = 5;\r\n                    case 5:\r\n                        alignedFaces = _a;\r\n                        return [4 /*yield*/, Promise.all(parentResults.map(function (parentResult, i) { return tslib_1.__awaiter(_this, void 0, void 0, function () {\r\n                                var descriptor;\r\n                                return tslib_1.__generator(this, function (_a) {\r\n                                    switch (_a.label) {\r\n                                        case 0: return [4 /*yield*/, nets.faceRecognitionNet.computeFaceDescriptor(alignedFaces[i])];\r\n                                        case 1:\r\n                                            descriptor = _a.sent();\r\n                                            return [2 /*return*/, extendWithFaceDescriptor(parentResult, descriptor)];\r\n                                    }\r\n                                });\r\n                            }); }))];\r\n                    case 6:\r\n                        results = _b.sent();\r\n                        alignedFaces.forEach(function (f) { return f instanceof tf.Tensor && f.dispose(); });\r\n                        return [2 /*return*/, results];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return ComputeAllFaceDescriptorsTask;\r\n}(ComputeFaceDescriptorsTaskBase));\r\nexport { ComputeAllFaceDescriptorsTask };\r\nvar ComputeSingleFaceDescriptorTask = /** @class */ (function (_super) {\r\n    tslib_1.__extends(ComputeSingleFaceDescriptorTask, _super);\r\n    function ComputeSingleFaceDescriptorTask() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    ComputeSingleFaceDescriptorTask.prototype.run = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            var parentResult, alignedRect, alignedFaces, _a, descriptor;\r\n            return tslib_1.__generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0: return [4 /*yield*/, this.parentTask];\r\n                    case 1:\r\n                        parentResult = _b.sent();\r\n                        if (!parentResult) {\r\n                            return [2 /*return*/];\r\n                        }\r\n                        alignedRect = parentResult.alignedRect;\r\n                        if (!(this.input instanceof tf.Tensor)) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, extractFaceTensors(this.input, [alignedRect])];\r\n                    case 2:\r\n                        _a = _b.sent();\r\n                        return [3 /*break*/, 5];\r\n                    case 3: return [4 /*yield*/, extractFaces(this.input, [alignedRect])];\r\n                    case 4:\r\n                        _a = _b.sent();\r\n                        _b.label = 5;\r\n                    case 5:\r\n                        alignedFaces = _a;\r\n                        return [4 /*yield*/, nets.faceRecognitionNet.computeFaceDescriptor(alignedFaces[0])];\r\n                    case 6:\r\n                        descriptor = _b.sent();\r\n                        alignedFaces.forEach(function (f) { return f instanceof tf.Tensor && f.dispose(); });\r\n                        return [2 /*return*/, extendWithFaceDescriptor(parentResult, descriptor)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return ComputeSingleFaceDescriptorTask;\r\n}(ComputeFaceDescriptorsTaskBase));\r\nexport { ComputeSingleFaceDescriptorTask };\r\n//# sourceMappingURL=ComputeFaceDescriptorsTasks.js.map"]},"metadata":{},"sourceType":"module"}