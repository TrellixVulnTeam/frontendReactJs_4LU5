'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var core = require('@react-pdf-viewer/core');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () {
                        return e[k];
                    }
                });
            }
        });
    }
    n['default'] = e;
    return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

var BookmarkItem = function (_a) {
    var bookmark = _a.bookmark, depth = _a.depth, doc = _a.doc, onClick = _a.onClick, onJumpToDest = _a.onJumpToDest;
    var toggleRef = React__namespace.createRef();
    var subItemRef = React__namespace.createRef();
    var subItemsDisplayed = React__namespace.useRef(true);
    var hasSubItems = bookmark.items && bookmark.items.length > 0;
    var toggleSubItems = function () {
        subItemsDisplayed.current = !subItemsDisplayed.current;
        var subItemsEle = subItemRef.current;
        var toggleEle = toggleRef.current;
        if (!subItemsEle || !toggleEle) {
            return;
        }
        subItemsEle.style.display = subItemsDisplayed.current ? 'block' : 'none';
        toggleEle.classList.toggle('rpv-bookmark-toggle-expanded');
    };
    var clickBookmak = function () {
        if (hasSubItems && bookmark.dest) {
            onClick(bookmark.dest);
        }
    };
    var clickItem = function () {
        if (!hasSubItems && bookmark.dest) {
            onClick(bookmark.dest);
        }
    };
    return (React__namespace.createElement(React__namespace.Fragment, null,
        React__namespace.createElement("div", { className: 'rpv-bookmark-item', style: {
                paddingLeft: depth * 20 + 4 + "px",
            }, onClick: clickItem },
            hasSubItems && (React__namespace.createElement("span", { ref: toggleRef, className: 'rpv-bookmark-toggle', onClick: toggleSubItems }, "\u25BA")),
            bookmark.url
                ? (React__namespace.createElement("a", { className: 'rpv-bookmark-title', href: bookmark.url, rel: 'noopener noreferrer nofollow', target: bookmark.newWindow ? '_blank' : '' }, bookmark.title))
                : (React__namespace.createElement("div", { className: 'rpv-bookmark-title', onClick: clickBookmak }, bookmark.title))),
        hasSubItems && (React__namespace.createElement("div", { ref: subItemRef },
            React__namespace.createElement(BookmarkList, { bookmarks: bookmark.items, depth: depth + 1, doc: doc, onJumpToDest: onJumpToDest })))));
};

var BookmarkList = function (_a) {
    var bookmarks = _a.bookmarks, _b = _a.depth, depth = _b === void 0 ? 0 : _b, doc = _a.doc, onJumpToDest = _a.onJumpToDest;
    var jumpToDest = function (dest) {
        core.getDestination(doc, dest).then(function (target) {
            var pageIndex = target.pageIndex, bottomOffset = target.bottomOffset, scaleTo = target.scaleTo;
            onJumpToDest(pageIndex + 1, bottomOffset, scaleTo);
        });
    };
    return (React__namespace.createElement("ul", { className: 'rpv-bookmark-list' }, bookmarks.map(function (bookmark, index) {
        return (React__namespace.createElement("li", { key: index },
            React__namespace.createElement(BookmarkItem, { bookmark: bookmark, depth: depth, doc: doc, onClick: jumpToDest, onJumpToDest: onJumpToDest })));
    })));
};

var BookmarkLoader = function (_a) {
    var doc = _a.doc, onJumpToDest = _a.onJumpToDest;
    var l10n = React__namespace.useContext(core.LocalizationContext);
    var _b = React__namespace.useState({
        isLoaded: false,
        items: [],
    }), bookmarks = _b[0], setBookmarks = _b[1];
    React__namespace.useEffect(function () {
        setBookmarks({
            isLoaded: false,
            items: [],
        });
        doc.getOutline().then(function (outline) {
            setBookmarks({
                isLoaded: true,
                items: outline || [],
            });
        });
    }, [doc]);
    return (!bookmarks.isLoaded
        ? React__namespace.createElement(core.Spinner, null)
        : (bookmarks.items.length === 0
            ? React__namespace.createElement("div", { className: 'rpv-bookmark-empty' }, l10n && l10n.bookmark ? l10n.bookmark.noBookmark : 'There is no bookmark')
            : (React__namespace.createElement(BookmarkList, { bookmarks: bookmarks.items, depth: 0, doc: doc, onJumpToDest: onJumpToDest }))));
};

var BookmarkListWithStore = function (_a) {
    var store = _a.store;
    var _b = React__namespace.useState(store.get('doc')), currentDoc = _b[0], setCurrentDoc = _b[1];
    var handleDocumentChanged = function (doc) {
        setCurrentDoc(doc);
    };
    var jump = function (pageIndex, bottomOffset, scaleTo) {
        var jumpToDestination = store.get('jumpToDestination');
        if (jumpToDestination) {
            jumpToDestination(pageIndex, bottomOffset, 0, scaleTo);
        }
    };
    React__namespace.useEffect(function () {
        store.subscribe('doc', handleDocumentChanged);
        return function () {
            store.unsubscribe('doc', handleDocumentChanged);
        };
    }, []);
    return (currentDoc
        ? (React__namespace.createElement(BookmarkLoader, { doc: currentDoc, onJumpToDest: jump }))
        : React__namespace.createElement("div", { className: 'rpv-bookmark-list-loader' },
            React__namespace.createElement(core.Spinner, null)));
};

var bookmarkPlugin = function () {
    var store = React__namespace.useMemo(function () { return core.createStore({}); }, []);
    var BookmarksDecorator = function () { return (React__namespace.createElement(BookmarkListWithStore, { store: store })); };
    return {
        install: function (pluginFunctions) {
            store.update('jumpToDestination', pluginFunctions.jumpToDestination);
        },
        onDocumentLoad: function (props) {
            store.update('doc', props.doc);
        },
        Bookmarks: BookmarksDecorator,
    };
};

exports.bookmarkPlugin = bookmarkPlugin;
